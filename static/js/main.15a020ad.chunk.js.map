{"version":3,"sources":["components/wave.ts","utils/points.ts","App.tsx","components/grid.ts","components/fence.ts","index.tsx"],"names":["createWave","positions","color","points","CatmullRomCurve3","getPoints","length","geometry","BufferGeometry","material","LineBasicMaterial","Line","createPoints","start","stop","inc","i","push","Vector3","wave1","wave2","connectorLine","aspect","window","innerWidth","innerHeight","camera","PerspectiveCamera","renderer","WebGLRenderer","antialias","scene","Scene","points1","points2","waveLength","Math","PI","App","this","init","setSize","setAnimationLoop","animation","lookAt","OrbitControls","domElement","target","position","set","grid","gridHelper","GridHelper","copy","createGrid","add","appContainer","document","querySelector","console","error","appendChild","entryWavePoints","exitWavePoints","fence","THREE","transparent","opacity","cube","clonedPicket","clone","translateZ","createFence","time","waveAngle","rotationAngle","amplitudeMultiplier","cos","getPtY","pt","sin","x","forEach","y","setFromPoints","rotation","abs","render","className","Component","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.15a020ad.chunk.js","sourcesContent":["import {\n\tBufferGeometry,\n\tCatmullRomCurve3,\n\tLine,\n\tLineBasicMaterial,\n} from 'three';\n\n/** Create a wave */\nexport function createWave(\n\tpositions: THREE.Vector3[],\n\tcolor: number\n): [\n\tpoints: THREE.Vector3[],\n\twaveLine: THREE.Line<THREE.BufferGeometry, THREE.LineBasicMaterial>\n] {\n\tconst curve = new CatmullRomCurve3(positions);\n\tconst points = curve.getPoints(positions.length);\n\n\tconst geometry = new BufferGeometry();\n\tconst material = new LineBasicMaterial({ color });\n\n\tconst waveLine = new Line(geometry, material);\n\n\treturn [points, waveLine];\n}\n","import { Vector3 } from 'three';\n\nexport function createPoints(start: number, stop: number, inc: number) {\n\tconst points = [];\n\n\tfor (let i = start; i <= stop; i += inc) {\n\t\tpoints.push(new Vector3(i, 0, 0));\n\t}\n\n\treturn points;\n}\n","import React, { Component } from 'react';\nimport './App.css';\nimport { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';\nimport { createFence } from './components/fence';\nimport { createWave } from './components/wave';\nimport { createGrid } from './components/grid';\nimport {\n\tBufferGeometry,\n\tLine,\n\tPerspectiveCamera,\n\tScene,\n\tVector3,\n\tWebGLRenderer,\n} from 'three';\nimport { createPoints } from './utils/points';\nimport { LineBasicMaterial } from 'three';\n\n// Globals\nconst aspect = window.innerWidth / window.innerHeight;\nconst camera: PerspectiveCamera = new PerspectiveCamera(55, aspect, 0.01, 100);\nconst renderer: WebGLRenderer = new WebGLRenderer({ antialias: true });\nconst scene: Scene = new Scene();\nlet points1: Vector3[] = [];\nlet points2: Vector3[] = [];\nlet wave1: Line;\nlet wave2: Line;\nlet waveLength: number = 2 * Math.PI;\nlet connectorLine: Line;\n\nclass App extends Component {\n\tcomponentDidMount() {\n\t\tthis.init();\n\t}\n\n\tinit() {\n\t\t/** General scene setup */\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\trenderer.setAnimationLoop(this.animation);\n\n\t\t/** Determine position to look at */\n\t\tconst lookAt = new Vector3(waveLength, 0, 0);\n\n\t\t/** Set the controls and update the controls target */\n\t\tconst controls = new OrbitControls(camera, renderer.domElement);\n\t\tcontrols.target = lookAt;\n\n\t\t/** Set the camera position */\n\t\tcamera.position.set(0, 5, 10);\n\t\tcamera.lookAt(lookAt);\n\n\t\t/** Grid to help user's perception of orientation */\n\t\tconst gridPosition = new Vector3(waveLength, -1, 0);\n\t\tconst grid = createGrid(gridPosition);\n\t\tscene.add(grid);\n\n\t\t/** Add renderer to app container */\n\t\tconst appContainer = document.querySelector('.App');\n\t\tif (!appContainer) {\n\t\t\treturn console.error(\"Couldn't get app container\");\n\t\t}\n\t\tappContainer.appendChild(renderer.domElement);\n\n\t\t/** Create points along line */\n\t\tconst entryWavePoints = createPoints(0, waveLength, 0.1);\n\t\tconst exitWavePoints = createPoints(waveLength, 2 * waveLength, 0.1);\n\n\t\t/** Create first wave */\n\t\t[points1, wave1] = createWave(entryWavePoints, 0x449aff);\n\t\tscene.add(wave1);\n\n\t\t/** Create second wave */\n\t\t[points2, wave2] = createWave(exitWavePoints, 0x9a44ff);\n\t\tscene.add(wave2);\n\n\t\t/** Connecting line */\n\t\tconnectorLine = new Line(\n\t\t\tnew BufferGeometry(),\n\t\t\tnew LineBasicMaterial({ color: 0x448aff })\n\t\t);\n\t\tscene.add(connectorLine);\n\n\t\t/** Picket fence */\n\t\tconst fence = createFence(new Vector3(waveLength, 0, -1));\n\t\tscene.add(fence);\n\t}\n\n\tanimation(time: number) {\n\t\t/** Angles */\n\t\tconst waveAngle = -time / 1000;\n\t\tconst rotationAngle = waveAngle / 2;\n\n\t\t/** Amplitude collapse  */\n\t\tconst amplitudeMultiplier = Math.cos(rotationAngle);\n\n\t\t// Helper\n\t\tconst getPtY = (pt: Vector3) => Math.sin(waveAngle + Math.PI * pt.x);\n\n\t\t/** Wave one adjustments */\n\t\t// Positions\n\t\tpoints1.forEach((pt) => {\n\t\t\tpt.y = getPtY(pt);\n\t\t});\n\t\twave1.geometry.setFromPoints(points1);\n\n\t\t// Rotation of wave about it's length\n\t\twave1.rotation.set(rotationAngle, 0, 0);\n\n\t\t/** Wave two adjustments */\n\t\t// Positions\n\t\tpoints2.forEach((pt) => {\n\t\t\tpt.y = getPtY(pt) * Math.abs(amplitudeMultiplier);\n\t\t});\n\t\twave2.geometry.setFromPoints(points2);\n\n\t\t/** Connector line */\n\t\t// TODO:  fix this coordinate translation...\n\t\t// const start = wave1.localToWorld(points1[points1.length - 1]);\n\t\t// const stop = points2[0];\n\t\t// connectorLine.geometry.setFromPoints([start, stop]);\n\n\t\t// Re-render scene\n\t\trenderer.render(scene, camera);\n\t}\n\n\trender() {\n\t\treturn <div className='App'></div>;\n\t}\n}\n\nexport default App;\n","import { GridHelper, Vector3 } from 'three';\n\nexport function createGrid(position: Vector3) {\n\tconst gridHelper = new GridHelper(10, 10);\n\tgridHelper.position.copy(position);\n\treturn gridHelper;\n}\n","import * as THREE from 'three';\n\n/** Picket fence */\nexport function createFence(position: THREE.Vector3): THREE.Group {\n\tconst geometry = new THREE.BoxGeometry(0.01, 2, 0.3);\n\tconst material = new THREE.MeshBasicMaterial({\n\t\tcolor: 0xaaaaaa,\n\t\ttransparent: true,\n\t\topacity: 0.7,\n\t});\n\n\tconst cube = new THREE.Mesh(geometry, material);\n\tcube.position.copy(position);\n\n\tconst fence = new THREE.Group();\n\tfor (let i = 0; i <= 2; i += 2 / 5) {\n\t\tconst clonedPicket = cube.clone();\n\t\tclonedPicket.translateZ(i);\n\t\tfence.add(clonedPicket);\n\t}\n\n\treturn fence;\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n\t<React.StrictMode>\n\t\t<App />\n\t</React.StrictMode>,\n\tdocument.getElementById('root')\n);\n"],"sourceRoot":""}